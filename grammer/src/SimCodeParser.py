# Generated from /home/galprz/simv2/grammer/SimCode.g4 by ANTLR 4.8
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3#")
        buf.write("\u00a6\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\3\2\3\2\5\2%\n\2\3")
        buf.write("\2\3\2\3\3\3\3\3\3\3\4\3\4\3\4\3\4\3\4\3\4\6\4\62\n\4")
        buf.write("\r\4\16\4\63\3\4\3\4\3\5\3\5\3\5\3\5\5\5<\n\5\3\6\3\6")
        buf.write("\3\6\3\6\3\6\3\6\5\6D\n\6\3\6\3\6\3\7\3\7\3\7\3\7\5\7")
        buf.write("L\n\7\3\7\3\7\3\7\6\7Q\n\7\r\7\16\7R\3\7\3\7\3\b\3\b\3")
        buf.write("\b\3\b\3\b\3\b\6\b]\n\b\r\b\16\b^\3\b\3\b\3\t\3\t\3\n")
        buf.write("\3\n\3\n\3\n\3\n\3\n\5\nk\n\n\3\n\3\n\3\n\3\n\5\nq\n\n")
        buf.write("\3\13\3\13\3\13\3\13\3\13\3\f\3\f\3\f\3\f\3\f\3\f\3\f")
        buf.write("\3\f\3\f\3\f\3\f\5\f\u0083\n\f\3\f\3\f\3\f\3\f\3\f\3\f")
        buf.write("\5\f\u008b\n\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\5\f\u0094\n")
        buf.write("\f\5\f\u0096\n\f\3\r\3\r\3\16\3\16\3\17\3\17\3\20\3\20")
        buf.write("\3\21\3\21\6\21\u00a2\n\21\r\21\16\21\u00a3\3\21\2\2\22")
        buf.write("\2\4\6\b\n\f\16\20\22\24\26\30\32\34\36 \2\5\3\2\27\34")
        buf.write("\3\2\36\37\3\2\22\26\2\u00b1\2$\3\2\2\2\4(\3\2\2\2\6+")
        buf.write("\3\2\2\2\b;\3\2\2\2\n=\3\2\2\2\fG\3\2\2\2\16V\3\2\2\2")
        buf.write("\20b\3\2\2\2\22p\3\2\2\2\24r\3\2\2\2\26\u0095\3\2\2\2")
        buf.write("\30\u0097\3\2\2\2\32\u0099\3\2\2\2\34\u009b\3\2\2\2\36")
        buf.write("\u009d\3\2\2\2 \u009f\3\2\2\2\"%\5\6\4\2#%\5\4\3\2$\"")
        buf.write("\3\2\2\2$#\3\2\2\2%&\3\2\2\2&\'\7\2\2\3\'\3\3\2\2\2()")
        buf.write("\7\"\2\2)*\b\3\1\2*\5\3\2\2\2+,\7\3\2\2,-\7\4\2\2-.\7")
        buf.write("\f\2\2./\7\r\2\2/\61\5\32\16\2\60\62\5\b\5\2\61\60\3\2")
        buf.write("\2\2\62\63\3\2\2\2\63\61\3\2\2\2\63\64\3\2\2\2\64\65\3")
        buf.write("\2\2\2\65\66\5\34\17\2\66\7\3\2\2\2\67<\5\24\13\28<\5")
        buf.write("\16\b\29<\5\f\7\2:<\5\n\6\2;\67\3\2\2\2;8\3\2\2\2;9\3")
        buf.write("\2\2\2;:\3\2\2\2<\t\3\2\2\2=C\7\b\2\2>D\5\36\20\2?D\7")
        buf.write("\37\2\2@D\5 \21\2AD\7\t\2\2BD\7\36\2\2C>\3\2\2\2C?\3\2")
        buf.write("\2\2C@\3\2\2\2CA\3\2\2\2CB\3\2\2\2DE\3\2\2\2EF\7\n\2\2")
        buf.write("F\13\3\2\2\2GH\7\7\2\2HK\7\f\2\2IL\7\37\2\2JL\5\36\20")
        buf.write("\2KI\3\2\2\2KJ\3\2\2\2LM\3\2\2\2MN\7\r\2\2NP\5\32\16\2")
        buf.write("OQ\5\b\5\2PO\3\2\2\2QR\3\2\2\2RP\3\2\2\2RS\3\2\2\2ST\3")
        buf.write("\2\2\2TU\5\34\17\2U\r\3\2\2\2VW\7\5\2\2WX\7\f\2\2XY\5")
        buf.write("\22\n\2YZ\7\r\2\2Z\\\5\32\16\2[]\5\b\5\2\\[\3\2\2\2]^")
        buf.write("\3\2\2\2^\\\3\2\2\2^_\3\2\2\2_`\3\2\2\2`a\5\34\17\2a\17")
        buf.write("\3\2\2\2bc\t\2\2\2c\21\3\2\2\2de\5\36\20\2ej\5\20\t\2")
        buf.write("fk\7\37\2\2gk\7\36\2\2hk\5 \21\2ik\7\t\2\2jf\3\2\2\2j")
        buf.write("g\3\2\2\2jh\3\2\2\2ji\3\2\2\2kq\3\2\2\2lm\5\36\20\2mn")
        buf.write("\5\20\t\2no\5\36\20\2oq\3\2\2\2pd\3\2\2\2pl\3\2\2\2q\23")
        buf.write("\3\2\2\2rs\5\36\20\2st\7\21\2\2tu\5\26\f\2uv\7\n\2\2v")
        buf.write("\25\3\2\2\2wx\5\36\20\2xy\5\30\r\2yz\5\36\20\2z\u0096")
        buf.write("\3\2\2\2{|\5\36\20\2|}\5\30\r\2}~\t\3\2\2~\u0096\3\2\2")
        buf.write("\2\177\u0083\7\37\2\2\u0080\u0083\7\36\2\2\u0081\u0083")
        buf.write("\5 \21\2\u0082\177\3\2\2\2\u0082\u0080\3\2\2\2\u0082\u0081")
        buf.write("\3\2\2\2\u0083\u0084\3\2\2\2\u0084\u0085\5\30\r\2\u0085")
        buf.write("\u0086\5\36\20\2\u0086\u0096\3\2\2\2\u0087\u008b\7\37")
        buf.write("\2\2\u0088\u008b\7\36\2\2\u0089\u008b\5 \21\2\u008a\u0087")
        buf.write("\3\2\2\2\u008a\u0088\3\2\2\2\u008a\u0089\3\2\2\2\u008b")
        buf.write("\u008c\3\2\2\2\u008c\u008d\5\30\r\2\u008d\u008e\t\3\2")
        buf.write("\2\u008e\u0096\3\2\2\2\u008f\u0094\7\37\2\2\u0090\u0094")
        buf.write("\5 \21\2\u0091\u0094\7\36\2\2\u0092\u0094\7\t\2\2\u0093")
        buf.write("\u008f\3\2\2\2\u0093\u0090\3\2\2\2\u0093\u0091\3\2\2\2")
        buf.write("\u0093\u0092\3\2\2\2\u0094\u0096\3\2\2\2\u0095w\3\2\2")
        buf.write("\2\u0095{\3\2\2\2\u0095\u0082\3\2\2\2\u0095\u008a\3\2")
        buf.write("\2\2\u0095\u0093\3\2\2\2\u0096\27\3\2\2\2\u0097\u0098")
        buf.write("\t\4\2\2\u0098\31\3\2\2\2\u0099\u009a\7\16\2\2\u009a\33")
        buf.write("\3\2\2\2\u009b\u009c\7\17\2\2\u009c\35\3\2\2\2\u009d\u009e")
        buf.write("\7 \2\2\u009e\37\3\2\2\2\u009f\u00a1\7\24\2\2\u00a0\u00a2")
        buf.write("\7#\2\2\u00a1\u00a0\3\2\2\2\u00a2\u00a3\3\2\2\2\u00a3")
        buf.write("\u00a1\3\2\2\2\u00a3\u00a4\3\2\2\2\u00a4!\3\2\2\2\20$")
        buf.write("\63;CKR^jp\u0082\u008a\u0093\u0095\u00a3")
        return buf.getvalue()


class SimCodeParser ( Parser ):

    grammarFileName = "SimCode.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "'0'", "';'", 
                     "'.'", "'('", "')'", "'{'", "'}'", "','", "'='", "'*'", 
                     "'+'", "'-'", "'//'", "'/'", "'<'", "'<='", "'>'", 
                     "'>='", "'=='", "'!='", "':'" ]

    symbolicNames = [ "<INVALID>", "FUNC", "SIMULATION_KEYWORD", "IF", "ELSE", 
                      "REPEAT", "RETURN", "ZERO", "SCOL", "DOT", "OPEN_PAR", 
                      "CLOSE_PAR", "OPEN_CURLY_PAR", "CLOSE_CURLY_PAR", 
                      "COMMA", "ASSIGN", "STAR", "PLUS", "MINUS", "INT_DIV", 
                      "DIV", "LT", "LT_EQ", "GT", "GT_EQ", "EQ", "NOT_EQ1", 
                      "COLON", "NUMERIC_LITERAL", "POSITIVE_INT", "IDENTIFIER", 
                      "SPACES", "UNEXPECTED_CHAR", "DIGIT" ]

    RULE_parse = 0
    RULE_error = 1
    RULE_simulation_fn = 2
    RULE_exp = 3
    RULE_return_stmt = 4
    RULE_repeat_stmt = 5
    RULE_if_stmt = 6
    RULE_comperation_operator = 7
    RULE_condition_expression = 8
    RULE_assignment_stmt = 9
    RULE_numeric_expression = 10
    RULE_operator = 11
    RULE_open_code_block = 12
    RULE_close_code_block = 13
    RULE_identifier = 14
    RULE_negative_int = 15

    ruleNames =  [ "parse", "error", "simulation_fn", "exp", "return_stmt", 
                   "repeat_stmt", "if_stmt", "comperation_operator", "condition_expression", 
                   "assignment_stmt", "numeric_expression", "operator", 
                   "open_code_block", "close_code_block", "identifier", 
                   "negative_int" ]

    EOF = Token.EOF
    FUNC=1
    SIMULATION_KEYWORD=2
    IF=3
    ELSE=4
    REPEAT=5
    RETURN=6
    ZERO=7
    SCOL=8
    DOT=9
    OPEN_PAR=10
    CLOSE_PAR=11
    OPEN_CURLY_PAR=12
    CLOSE_CURLY_PAR=13
    COMMA=14
    ASSIGN=15
    STAR=16
    PLUS=17
    MINUS=18
    INT_DIV=19
    DIV=20
    LT=21
    LT_EQ=22
    GT=23
    GT_EQ=24
    EQ=25
    NOT_EQ1=26
    COLON=27
    NUMERIC_LITERAL=28
    POSITIVE_INT=29
    IDENTIFIER=30
    SPACES=31
    UNEXPECTED_CHAR=32
    DIGIT=33

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.8")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class ParseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(SimCodeParser.EOF, 0)

        def simulation_fn(self):
            return self.getTypedRuleContext(SimCodeParser.Simulation_fnContext,0)


        def error(self):
            return self.getTypedRuleContext(SimCodeParser.ErrorContext,0)


        def getRuleIndex(self):
            return SimCodeParser.RULE_parse

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParse" ):
                listener.enterParse(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParse" ):
                listener.exitParse(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParse" ):
                return visitor.visitParse(self)
            else:
                return visitor.visitChildren(self)




    def parse(self):

        localctx = SimCodeParser.ParseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_parse)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 34
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [SimCodeParser.FUNC]:
                self.state = 32
                self.simulation_fn()
                pass
            elif token in [SimCodeParser.UNEXPECTED_CHAR]:
                self.state = 33
                self.error()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 36
            self.match(SimCodeParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ErrorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._UNEXPECTED_CHAR = None # Token

        def UNEXPECTED_CHAR(self):
            return self.getToken(SimCodeParser.UNEXPECTED_CHAR, 0)

        def getRuleIndex(self):
            return SimCodeParser.RULE_error

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterError" ):
                listener.enterError(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitError" ):
                listener.exitError(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitError" ):
                return visitor.visitError(self)
            else:
                return visitor.visitChildren(self)




    def error(self):

        localctx = SimCodeParser.ErrorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_error)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 38
            localctx._UNEXPECTED_CHAR = self.match(SimCodeParser.UNEXPECTED_CHAR)

            raise RuntimeError("UNEXPECTED_CHAR=" + (None if localctx._UNEXPECTED_CHAR is None else localctx._UNEXPECTED_CHAR.text));
               
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Simulation_fnContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FUNC(self):
            return self.getToken(SimCodeParser.FUNC, 0)

        def SIMULATION_KEYWORD(self):
            return self.getToken(SimCodeParser.SIMULATION_KEYWORD, 0)

        def OPEN_PAR(self):
            return self.getToken(SimCodeParser.OPEN_PAR, 0)

        def CLOSE_PAR(self):
            return self.getToken(SimCodeParser.CLOSE_PAR, 0)

        def open_code_block(self):
            return self.getTypedRuleContext(SimCodeParser.Open_code_blockContext,0)


        def close_code_block(self):
            return self.getTypedRuleContext(SimCodeParser.Close_code_blockContext,0)


        def exp(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SimCodeParser.ExpContext)
            else:
                return self.getTypedRuleContext(SimCodeParser.ExpContext,i)


        def getRuleIndex(self):
            return SimCodeParser.RULE_simulation_fn

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimulation_fn" ):
                listener.enterSimulation_fn(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimulation_fn" ):
                listener.exitSimulation_fn(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimulation_fn" ):
                return visitor.visitSimulation_fn(self)
            else:
                return visitor.visitChildren(self)




    def simulation_fn(self):

        localctx = SimCodeParser.Simulation_fnContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_simulation_fn)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 41
            self.match(SimCodeParser.FUNC)
            self.state = 42
            self.match(SimCodeParser.SIMULATION_KEYWORD)
            self.state = 43
            self.match(SimCodeParser.OPEN_PAR)
            self.state = 44
            self.match(SimCodeParser.CLOSE_PAR)
            self.state = 45
            self.open_code_block()
            self.state = 47 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 46
                self.exp()
                self.state = 49 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << SimCodeParser.IF) | (1 << SimCodeParser.REPEAT) | (1 << SimCodeParser.RETURN) | (1 << SimCodeParser.IDENTIFIER))) != 0)):
                    break

            self.state = 51
            self.close_code_block()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def assignment_stmt(self):
            return self.getTypedRuleContext(SimCodeParser.Assignment_stmtContext,0)


        def if_stmt(self):
            return self.getTypedRuleContext(SimCodeParser.If_stmtContext,0)


        def repeat_stmt(self):
            return self.getTypedRuleContext(SimCodeParser.Repeat_stmtContext,0)


        def return_stmt(self):
            return self.getTypedRuleContext(SimCodeParser.Return_stmtContext,0)


        def getRuleIndex(self):
            return SimCodeParser.RULE_exp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExp" ):
                listener.enterExp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExp" ):
                listener.exitExp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExp" ):
                return visitor.visitExp(self)
            else:
                return visitor.visitChildren(self)




    def exp(self):

        localctx = SimCodeParser.ExpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_exp)
        try:
            self.state = 57
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [SimCodeParser.IDENTIFIER]:
                self.enterOuterAlt(localctx, 1)
                self.state = 53
                self.assignment_stmt()
                pass
            elif token in [SimCodeParser.IF]:
                self.enterOuterAlt(localctx, 2)
                self.state = 54
                self.if_stmt()
                pass
            elif token in [SimCodeParser.REPEAT]:
                self.enterOuterAlt(localctx, 3)
                self.state = 55
                self.repeat_stmt()
                pass
            elif token in [SimCodeParser.RETURN]:
                self.enterOuterAlt(localctx, 4)
                self.state = 56
                self.return_stmt()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Return_stmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RETURN(self):
            return self.getToken(SimCodeParser.RETURN, 0)

        def SCOL(self):
            return self.getToken(SimCodeParser.SCOL, 0)

        def identifier(self):
            return self.getTypedRuleContext(SimCodeParser.IdentifierContext,0)


        def POSITIVE_INT(self):
            return self.getToken(SimCodeParser.POSITIVE_INT, 0)

        def negative_int(self):
            return self.getTypedRuleContext(SimCodeParser.Negative_intContext,0)


        def ZERO(self):
            return self.getToken(SimCodeParser.ZERO, 0)

        def NUMERIC_LITERAL(self):
            return self.getToken(SimCodeParser.NUMERIC_LITERAL, 0)

        def getRuleIndex(self):
            return SimCodeParser.RULE_return_stmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReturn_stmt" ):
                listener.enterReturn_stmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReturn_stmt" ):
                listener.exitReturn_stmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReturn_stmt" ):
                return visitor.visitReturn_stmt(self)
            else:
                return visitor.visitChildren(self)




    def return_stmt(self):

        localctx = SimCodeParser.Return_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_return_stmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 59
            self.match(SimCodeParser.RETURN)
            self.state = 65
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [SimCodeParser.IDENTIFIER]:
                self.state = 60
                self.identifier()
                pass
            elif token in [SimCodeParser.POSITIVE_INT]:
                self.state = 61
                self.match(SimCodeParser.POSITIVE_INT)
                pass
            elif token in [SimCodeParser.MINUS]:
                self.state = 62
                self.negative_int()
                pass
            elif token in [SimCodeParser.ZERO]:
                self.state = 63
                self.match(SimCodeParser.ZERO)
                pass
            elif token in [SimCodeParser.NUMERIC_LITERAL]:
                self.state = 64
                self.match(SimCodeParser.NUMERIC_LITERAL)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 67
            self.match(SimCodeParser.SCOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Repeat_stmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REPEAT(self):
            return self.getToken(SimCodeParser.REPEAT, 0)

        def OPEN_PAR(self):
            return self.getToken(SimCodeParser.OPEN_PAR, 0)

        def CLOSE_PAR(self):
            return self.getToken(SimCodeParser.CLOSE_PAR, 0)

        def open_code_block(self):
            return self.getTypedRuleContext(SimCodeParser.Open_code_blockContext,0)


        def close_code_block(self):
            return self.getTypedRuleContext(SimCodeParser.Close_code_blockContext,0)


        def POSITIVE_INT(self):
            return self.getToken(SimCodeParser.POSITIVE_INT, 0)

        def identifier(self):
            return self.getTypedRuleContext(SimCodeParser.IdentifierContext,0)


        def exp(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SimCodeParser.ExpContext)
            else:
                return self.getTypedRuleContext(SimCodeParser.ExpContext,i)


        def getRuleIndex(self):
            return SimCodeParser.RULE_repeat_stmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRepeat_stmt" ):
                listener.enterRepeat_stmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRepeat_stmt" ):
                listener.exitRepeat_stmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRepeat_stmt" ):
                return visitor.visitRepeat_stmt(self)
            else:
                return visitor.visitChildren(self)




    def repeat_stmt(self):

        localctx = SimCodeParser.Repeat_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_repeat_stmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 69
            self.match(SimCodeParser.REPEAT)
            self.state = 70
            self.match(SimCodeParser.OPEN_PAR)
            self.state = 73
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [SimCodeParser.POSITIVE_INT]:
                self.state = 71
                self.match(SimCodeParser.POSITIVE_INT)
                pass
            elif token in [SimCodeParser.IDENTIFIER]:
                self.state = 72
                self.identifier()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 75
            self.match(SimCodeParser.CLOSE_PAR)
            self.state = 76
            self.open_code_block()
            self.state = 78 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 77
                self.exp()
                self.state = 80 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << SimCodeParser.IF) | (1 << SimCodeParser.REPEAT) | (1 << SimCodeParser.RETURN) | (1 << SimCodeParser.IDENTIFIER))) != 0)):
                    break

            self.state = 82
            self.close_code_block()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class If_stmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF(self):
            return self.getToken(SimCodeParser.IF, 0)

        def OPEN_PAR(self):
            return self.getToken(SimCodeParser.OPEN_PAR, 0)

        def condition_expression(self):
            return self.getTypedRuleContext(SimCodeParser.Condition_expressionContext,0)


        def CLOSE_PAR(self):
            return self.getToken(SimCodeParser.CLOSE_PAR, 0)

        def open_code_block(self):
            return self.getTypedRuleContext(SimCodeParser.Open_code_blockContext,0)


        def close_code_block(self):
            return self.getTypedRuleContext(SimCodeParser.Close_code_blockContext,0)


        def exp(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SimCodeParser.ExpContext)
            else:
                return self.getTypedRuleContext(SimCodeParser.ExpContext,i)


        def getRuleIndex(self):
            return SimCodeParser.RULE_if_stmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIf_stmt" ):
                listener.enterIf_stmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIf_stmt" ):
                listener.exitIf_stmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIf_stmt" ):
                return visitor.visitIf_stmt(self)
            else:
                return visitor.visitChildren(self)




    def if_stmt(self):

        localctx = SimCodeParser.If_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_if_stmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 84
            self.match(SimCodeParser.IF)
            self.state = 85
            self.match(SimCodeParser.OPEN_PAR)
            self.state = 86
            self.condition_expression()
            self.state = 87
            self.match(SimCodeParser.CLOSE_PAR)
            self.state = 88
            self.open_code_block()
            self.state = 90 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 89
                self.exp()
                self.state = 92 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << SimCodeParser.IF) | (1 << SimCodeParser.REPEAT) | (1 << SimCodeParser.RETURN) | (1 << SimCodeParser.IDENTIFIER))) != 0)):
                    break

            self.state = 94
            self.close_code_block()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Comperation_operatorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LT(self):
            return self.getToken(SimCodeParser.LT, 0)

        def GT(self):
            return self.getToken(SimCodeParser.GT, 0)

        def LT_EQ(self):
            return self.getToken(SimCodeParser.LT_EQ, 0)

        def GT_EQ(self):
            return self.getToken(SimCodeParser.GT_EQ, 0)

        def EQ(self):
            return self.getToken(SimCodeParser.EQ, 0)

        def NOT_EQ1(self):
            return self.getToken(SimCodeParser.NOT_EQ1, 0)

        def getRuleIndex(self):
            return SimCodeParser.RULE_comperation_operator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComperation_operator" ):
                listener.enterComperation_operator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComperation_operator" ):
                listener.exitComperation_operator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComperation_operator" ):
                return visitor.visitComperation_operator(self)
            else:
                return visitor.visitChildren(self)




    def comperation_operator(self):

        localctx = SimCodeParser.Comperation_operatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_comperation_operator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 96
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << SimCodeParser.LT) | (1 << SimCodeParser.LT_EQ) | (1 << SimCodeParser.GT) | (1 << SimCodeParser.GT_EQ) | (1 << SimCodeParser.EQ) | (1 << SimCodeParser.NOT_EQ1))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Condition_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SimCodeParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(SimCodeParser.IdentifierContext,i)


        def comperation_operator(self):
            return self.getTypedRuleContext(SimCodeParser.Comperation_operatorContext,0)


        def POSITIVE_INT(self):
            return self.getToken(SimCodeParser.POSITIVE_INT, 0)

        def NUMERIC_LITERAL(self):
            return self.getToken(SimCodeParser.NUMERIC_LITERAL, 0)

        def negative_int(self):
            return self.getTypedRuleContext(SimCodeParser.Negative_intContext,0)


        def ZERO(self):
            return self.getToken(SimCodeParser.ZERO, 0)

        def getRuleIndex(self):
            return SimCodeParser.RULE_condition_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCondition_expression" ):
                listener.enterCondition_expression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCondition_expression" ):
                listener.exitCondition_expression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCondition_expression" ):
                return visitor.visitCondition_expression(self)
            else:
                return visitor.visitChildren(self)




    def condition_expression(self):

        localctx = SimCodeParser.Condition_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_condition_expression)
        try:
            self.state = 110
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,8,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 98
                self.identifier()
                self.state = 99
                self.comperation_operator()
                self.state = 104
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [SimCodeParser.POSITIVE_INT]:
                    self.state = 100
                    self.match(SimCodeParser.POSITIVE_INT)
                    pass
                elif token in [SimCodeParser.NUMERIC_LITERAL]:
                    self.state = 101
                    self.match(SimCodeParser.NUMERIC_LITERAL)
                    pass
                elif token in [SimCodeParser.MINUS]:
                    self.state = 102
                    self.negative_int()
                    pass
                elif token in [SimCodeParser.ZERO]:
                    self.state = 103
                    self.match(SimCodeParser.ZERO)
                    pass
                else:
                    raise NoViableAltException(self)

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 106
                self.identifier()
                self.state = 107
                self.comperation_operator()
                self.state = 108
                self.identifier()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Assignment_stmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(SimCodeParser.IdentifierContext,0)


        def ASSIGN(self):
            return self.getToken(SimCodeParser.ASSIGN, 0)

        def SCOL(self):
            return self.getToken(SimCodeParser.SCOL, 0)

        def numeric_expression(self):
            return self.getTypedRuleContext(SimCodeParser.Numeric_expressionContext,0)


        def getRuleIndex(self):
            return SimCodeParser.RULE_assignment_stmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssignment_stmt" ):
                listener.enterAssignment_stmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssignment_stmt" ):
                listener.exitAssignment_stmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssignment_stmt" ):
                return visitor.visitAssignment_stmt(self)
            else:
                return visitor.visitChildren(self)




    def assignment_stmt(self):

        localctx = SimCodeParser.Assignment_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_assignment_stmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 112
            self.identifier()
            self.state = 113
            self.match(SimCodeParser.ASSIGN)

            self.state = 114
            self.numeric_expression()
            self.state = 115
            self.match(SimCodeParser.SCOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Numeric_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SimCodeParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(SimCodeParser.IdentifierContext,i)


        def operator(self):
            return self.getTypedRuleContext(SimCodeParser.OperatorContext,0)


        def POSITIVE_INT(self, i:int=None):
            if i is None:
                return self.getTokens(SimCodeParser.POSITIVE_INT)
            else:
                return self.getToken(SimCodeParser.POSITIVE_INT, i)

        def NUMERIC_LITERAL(self, i:int=None):
            if i is None:
                return self.getTokens(SimCodeParser.NUMERIC_LITERAL)
            else:
                return self.getToken(SimCodeParser.NUMERIC_LITERAL, i)

        def negative_int(self):
            return self.getTypedRuleContext(SimCodeParser.Negative_intContext,0)


        def ZERO(self):
            return self.getToken(SimCodeParser.ZERO, 0)

        def getRuleIndex(self):
            return SimCodeParser.RULE_numeric_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumeric_expression" ):
                listener.enterNumeric_expression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumeric_expression" ):
                listener.exitNumeric_expression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumeric_expression" ):
                return visitor.visitNumeric_expression(self)
            else:
                return visitor.visitChildren(self)




    def numeric_expression(self):

        localctx = SimCodeParser.Numeric_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_numeric_expression)
        self._la = 0 # Token type
        try:
            self.state = 147
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,12,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 117
                self.identifier()
                self.state = 118
                self.operator()
                self.state = 119
                self.identifier()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 121
                self.identifier()
                self.state = 122
                self.operator()
                self.state = 123
                _la = self._input.LA(1)
                if not(_la==SimCodeParser.NUMERIC_LITERAL or _la==SimCodeParser.POSITIVE_INT):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 128
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [SimCodeParser.POSITIVE_INT]:
                    self.state = 125
                    self.match(SimCodeParser.POSITIVE_INT)
                    pass
                elif token in [SimCodeParser.NUMERIC_LITERAL]:
                    self.state = 126
                    self.match(SimCodeParser.NUMERIC_LITERAL)
                    pass
                elif token in [SimCodeParser.MINUS]:
                    self.state = 127
                    self.negative_int()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 130
                self.operator()
                self.state = 131
                self.identifier()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 136
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [SimCodeParser.POSITIVE_INT]:
                    self.state = 133
                    self.match(SimCodeParser.POSITIVE_INT)
                    pass
                elif token in [SimCodeParser.NUMERIC_LITERAL]:
                    self.state = 134
                    self.match(SimCodeParser.NUMERIC_LITERAL)
                    pass
                elif token in [SimCodeParser.MINUS]:
                    self.state = 135
                    self.negative_int()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 138
                self.operator()
                self.state = 139
                _la = self._input.LA(1)
                if not(_la==SimCodeParser.NUMERIC_LITERAL or _la==SimCodeParser.POSITIVE_INT):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 145
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [SimCodeParser.POSITIVE_INT]:
                    self.state = 141
                    self.match(SimCodeParser.POSITIVE_INT)
                    pass
                elif token in [SimCodeParser.MINUS]:
                    self.state = 142
                    self.negative_int()
                    pass
                elif token in [SimCodeParser.NUMERIC_LITERAL]:
                    self.state = 143
                    self.match(SimCodeParser.NUMERIC_LITERAL)
                    pass
                elif token in [SimCodeParser.ZERO]:
                    self.state = 144
                    self.match(SimCodeParser.ZERO)
                    pass
                else:
                    raise NoViableAltException(self)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OperatorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PLUS(self):
            return self.getToken(SimCodeParser.PLUS, 0)

        def MINUS(self):
            return self.getToken(SimCodeParser.MINUS, 0)

        def STAR(self):
            return self.getToken(SimCodeParser.STAR, 0)

        def DIV(self):
            return self.getToken(SimCodeParser.DIV, 0)

        def INT_DIV(self):
            return self.getToken(SimCodeParser.INT_DIV, 0)

        def getRuleIndex(self):
            return SimCodeParser.RULE_operator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOperator" ):
                listener.enterOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOperator" ):
                listener.exitOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOperator" ):
                return visitor.visitOperator(self)
            else:
                return visitor.visitChildren(self)




    def operator(self):

        localctx = SimCodeParser.OperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_operator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 149
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << SimCodeParser.STAR) | (1 << SimCodeParser.PLUS) | (1 << SimCodeParser.MINUS) | (1 << SimCodeParser.INT_DIV) | (1 << SimCodeParser.DIV))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Open_code_blockContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_CURLY_PAR(self):
            return self.getToken(SimCodeParser.OPEN_CURLY_PAR, 0)

        def getRuleIndex(self):
            return SimCodeParser.RULE_open_code_block

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpen_code_block" ):
                listener.enterOpen_code_block(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpen_code_block" ):
                listener.exitOpen_code_block(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOpen_code_block" ):
                return visitor.visitOpen_code_block(self)
            else:
                return visitor.visitChildren(self)




    def open_code_block(self):

        localctx = SimCodeParser.Open_code_blockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_open_code_block)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 151
            self.match(SimCodeParser.OPEN_CURLY_PAR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Close_code_blockContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CLOSE_CURLY_PAR(self):
            return self.getToken(SimCodeParser.CLOSE_CURLY_PAR, 0)

        def getRuleIndex(self):
            return SimCodeParser.RULE_close_code_block

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClose_code_block" ):
                listener.enterClose_code_block(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClose_code_block" ):
                listener.exitClose_code_block(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClose_code_block" ):
                return visitor.visitClose_code_block(self)
            else:
                return visitor.visitChildren(self)




    def close_code_block(self):

        localctx = SimCodeParser.Close_code_blockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_close_code_block)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 153
            self.match(SimCodeParser.CLOSE_CURLY_PAR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(SimCodeParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return SimCodeParser.RULE_identifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifier" ):
                listener.enterIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifier" ):
                listener.exitIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifier" ):
                return visitor.visitIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def identifier(self):

        localctx = SimCodeParser.IdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_identifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 155
            self.match(SimCodeParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Negative_intContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MINUS(self):
            return self.getToken(SimCodeParser.MINUS, 0)

        def DIGIT(self, i:int=None):
            if i is None:
                return self.getTokens(SimCodeParser.DIGIT)
            else:
                return self.getToken(SimCodeParser.DIGIT, i)

        def getRuleIndex(self):
            return SimCodeParser.RULE_negative_int

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNegative_int" ):
                listener.enterNegative_int(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNegative_int" ):
                listener.exitNegative_int(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNegative_int" ):
                return visitor.visitNegative_int(self)
            else:
                return visitor.visitChildren(self)




    def negative_int(self):

        localctx = SimCodeParser.Negative_intContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_negative_int)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 157
            self.match(SimCodeParser.MINUS)
            self.state = 159 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 158
                self.match(SimCodeParser.DIGIT)
                self.state = 161 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==SimCodeParser.DIGIT):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





